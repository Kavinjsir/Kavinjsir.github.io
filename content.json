{"meta":{"title":"King's Blog","subtitle":"From the very Beginning to the very Deep Learning","description":"Thoughts of Coding","author":"Tony King","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"数据结构与算法（一）并查集","slug":"QuickFind","date":"2017-11-07T13:52:42.000Z","updated":"2017-11-07T16:28:35.000Z","comments":true,"path":"2017/11/07/QuickFind/","link":"","permalink":"http://yoursite.com/2017/11/07/QuickFind/","excerpt":"","text":"开篇写什么一直没拿定，最后选择讲并查集是因为这两日一直在看，而且这块内容较为简单。至于为什么开题是“数据结构与算法”？因为这是我这段时间主要在学习的内容，我打算通过写博文的方式把学完的知识再巩固一遍，顺便把第一遍没来得及研究的东西尝试一下。另外，这一系列的code我会以c++为主。好了，废话不多说，让我们开始吧。 并查集，通常指英文中Union Find的问题。举个例子，一张地图，上面有若干城市。城市间本不相通，但是我们可以用铁轨将两个城市连通起来。然后，我们希望能快速得知能否从一个城市出发到达另一个城市。值得注意的是，这里期望得到的答案仅仅是 能 或者 不能 ，并查集问题不关心 怎样到达。\u0010\u0010\u0010\u0010\u0010\u0010\u0010\u0010\u0010 因此，简单说，并查集主要分为两个问题，一是 联通 Union；二是 查找 find。在实际代码中，通常使用一个数组来维护每个结点（城市）和它联通的结点的关系，比如：1int val = array[i] //array.length == n上述代码中，n表示总共有多少个结点；i为数组的索引值，指代结点；val表示与i连通的结点，因此val &lt; n。 有了相关数据结构维护数据后，接下来需要声明及定义相关函数（方法），在并查集，主要有三个方法： union(p, q) : 连通p、q两个结点 find(p) : 找到与p相连的结点 isConnected(p, q) : 查看p、q是否相连。 现在我们讨论一下三个方法的具体实现。find(i)思路很简单，我们只要返回array[i]的值即可。isConnected(i,j)也很简单，返回(find(i) == find(j))?即可。至于union(i,j)稍微复杂一些。假设我们有 0，1，2 这3个结点，初始时结点独立，于是： array[0] = 0; array[1] = 1; array[2] = 2;可以形象地理解为，此时结点只和自己相连。现在我们连接0，1，直观的做法是先调用 find(i) 函数，找到 0，1 各自的连通结点 i，j ，然后使用 union(i,j) 把各自连通的结点连接起来，这里假设 union(0,1) 使得 array[0] = 1 。按照这个逻辑，现在 union(1,2) 会使得 array[1] = 2 。看起来没有问题，但如果这时我们查看 0,2 的连通情况: find(0) == 1; find(2) == 2;这样就不能马上知道，0，2 是不是相连了。（甚至会被判断为不相连。）以这个例子为例，通常的解决方式是，在 union(1,2) 时，遍历数组，把 find(i) == 1 的元素都改为： array[i] = 2 。现在，我们已经可以写出初步的代码来实现基本的并查集功能了：12345678910111213141516171819202122232425262728293031323334353637383940414243444546class UnionFind &#123;private: int *id;//数组维护结点与其连通的结点值，注意它是类私有的，不暴露给用户 int count;//总共有多少个结点public: //构造函数 UnionFind(int n)&#123; count = n; id = new int[n]; for(int i = 0; i &lt; n; ++i)&#123; id[i] = i; &#125; &#125; //析构函数 ~UnionFind()&#123; delete[] id; &#125; int find(int p)&#123; assert( p &gt;= 0 &amp;&amp; p &lt; count); return id[p]; &#125; bool isConnected(int p, int q)&#123; return find(p) == find(q); &#125; void unionElements(int p, int q)&#123; int pID = find(p); int qID = find(q); if(pID == qID)&#123; return; &#125; for(int i = 0; i &lt; count; ++i)&#123;//遍历数组，当数据量增大，反复union的开销可想而知 if(id[i] == pID)&#123; id[i] = qID; &#125; &#125; &#125;&#125;;这个代码能用吗？显然是不行的，我在本地测试时，这样的方法在处理100000个数据时，耗时就达到了20s以上。原因便是在union的时候每次都要遍历一遍数组，而并查集的目的就是快。所以接下来我们逐步讨论关于这段代码的n种优化方法。（不多不多，目前所知的也就4种吧，当然以后知道更多的我肯定会更新啦。） 第一种优化方法：我们直接在 find() 函数更新结点的连通结点：12345678int find(int p)&#123; assert( p &gt;= 0 &amp;&amp; p &lt; count); while(p != parent[p])&#123; p = parent[p]; &#125; return p;&#125;可以看到现在我们的数组名字改成了 parent。以原先的 0, 1, 2 为例，如果 1, 2 相连， 0, 1 相连，那么现在在 find(0) 的过程中，我们会把 0 指向 2 。这时可以形象理解成，2是根结点，0，1是子结点。parent名字由此得来：parent[i] 指 i 连通的根结点。这样做的好处是，虽然在 find() 时牺牲了些许时间，但是在 union() 时却免去了遍历的操作：1234567891011void unionElements(int p, int q)&#123; int pRoot = find(p); int qRoot = find(q); if(pRoot == qRoot)&#123; return;; &#125; parent[pRoot] = parent[qRoot];&#125;在实际测试时，现在消耗的时间相比之前几乎少了一半，然而100000级别的数据从20s降到10s仍然是不理想的。 第二种优化方法：在构造类时新增一个数组变量 int* sz 。这个变量维护每个结点有多少个“子结点”。如，对于 i 每当它成为另一个结点的“父亲”时，sz[i]++ 。有了这个变量，我们在 union 时，就可以更智能地选择谁做“根结点”。对于union(i, j) :我们先用 find() 找到它们的根结点 iRoot, jRoot ，这时我们查看 iRoot, jRoot 对应 sz[]中的值，谁大谁做根。这样做很大程度上避免了诸如 a-&gt;b b-&gt;c c-&gt;d …这种树高过长的情况。由于现在的find复杂度由“树高”决定，树高被控制住了，搜索时间也就节省了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class UnionFind&#123;private: int* parent; int* sz; int count;public: UnionFind(int count)&#123; parent = new int[count]; sz = new int[count]; this-&gt;count = count; for (int i = 0; i &lt; count; ++i) &#123; parent[i] = i; sz[i] = 1; &#125; &#125; ~UnionFind()&#123; delete[] parent; delete[] sz; &#125; int find(int p)&#123; assert( p &gt;= 0 &amp;&amp; p &lt; count); while(p != parent[p])&#123; p = parent[p]; &#125; &#125; bool isConnected(int p, int q)&#123; return find(q) == find(p); &#125; void unionElements(int p, int q)&#123; int pRoot = find(p); int qRoot = find(q); if(pRoot == qRoot)&#123; return; &#125; if(sz[pRoot] &lt; sz[qRoot])&#123; parent[pRoot] = qRoot; sz[qRoot] += sz[pRoot]; &#125; else &#123; parent[qRoot] = pRoot; sz[pRoot] += sz[qRoot]; &#125; &#125;&#125;;这次优化后，处理100000个数据的耗时降到了毫秒级，可以应付实际的大部分问题了。但是在个别极端数据上还是会出现树高难以控制的问题。举个例子，假设现在有 a 为根的连通情况：a-&gt;b-&gt;c-&gt;d ，那么 sz[a] 为3。同时我们有 x 为根的连通情况：x-&gt;y x-&gt;z x-&gt;u x-&gt;v ，那么有 sz[x] 为4。此时我们要连通 a x 。按照先前的逻辑，sz[a] &lt; sz[x] , x 将成为 a 根，树高变成5，find(d) 要找4次才找到 x 。很显然，这种情况我们应该以 a 为根。故 sz 存在不合理性。 第三种优化方法：从根本上说，sz 就存在着不合理性，因此我们不应该用这种方式来处理（尽管在绝大部分情况下，这种方式的表现已经堪称优秀。）抛弃 sz ，现在重新构思一个数组，根据刚才的例子，它所维护的应该是树的高度，而非子孙的数量！这样在 union 的时候，比较两个根的树高，谁高谁做爹。只有在树高一样时才取其一做爹，树高+1。1234567891011121314151617void unionElements(int p, int q)&#123; int pRoot = find(p); int qRoot = find(q); if(pRoot == qRoot)&#123; return; &#125; if(rank[pRoot] &lt; rank[qRoot])&#123; parent[pRoot] = qRoot; &#125; else if(rank[qRoot] &lt; rank[pRoot])&#123; parent[qRoot] = pRoot; &#125; else&#123; parent[pRoot] = qRoot; rank[qRoot]++; &#125;&#125;实际测试，在绝大部分情况下，它的速度都是不如前面的，毕竟极端情况是少数。而为了应对这种极端情况，在 union 需要多做几次判断，这也是速度慢下来的原因。 第四种优化方法（重点：路径压缩）：还记得刚开始的优化方式，修改 find() 函数吗？其实在这里还可以再优化，在循环寻找根的途中，我们可以同时更新其parent中的值。下贴完整代码（注意find()函数中的改动，只添加了一句）：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class UnionFind&#123;private: int* rank; int* parent; int count;public: UnionFind(int count)&#123; parent = new int[count]; rank = new int[count]; this-&gt;count = count; for (int i = 0; i &lt; count; ++i) &#123; parent[i] = i; rank[i] = 1; &#125; &#125; ~UnionFind()&#123; delete[] parent; delete[] rank; &#125; int find(int p )&#123; assert(p&gt;= 0 &amp;&amp; p &lt; count); while(p != parent[p])&#123; parent[p] = parent[parent[p]]; p = parent[p]; &#125; return p; &#125; bool isConnected(int p, int q)&#123; return find(p) == find(q); &#125; void unionElements(int p ,int q)&#123; int pRoot = find(p); int qRoot = find(q); if(pRoot == qRoot)&#123; return; &#125; if(rank[pRoot] &lt; rank[qRoot])&#123; parent[pRoot] =qRoot; &#125; else if(rank[pRoot] &gt; rank[qRoot])&#123; parent[qRoot] = pRoot; &#125; else&#123; parent[pRoot] = qRoot; rank[qRoot]++; &#125; &#125;&#125;;现在进行测试，性能比第三种有明显提升，但是仍然不能达到第二种优化的性能。 总结到此并查集的基础知识就讨论完了，尽管在多次测试下，第二种优化都领先其他方法，但是从严谨的角度，个人仍然偏向用第四版代码，即路径压缩。这里存在两个问题，尚未完全解决：1.首先路径压缩的过程是会改变“树高”的，但是rank值并未在此更新，事实上似乎也没有必要更新，这是为什么呢？2.既然路径压缩是在第三种优化方式上的加强，那为何不把路径压缩也加入到第二种优化方式里面呢？（我做了相关的测试，结果却是比原来更慢了。） 最后，本次并查集的学习参考了Yubo Liu的相关代码，本人目前也是通过他的课程在进行相关知识的复习、学习，特此表示感谢！","categories":[],"tags":[]},{"title":"Hello King's Blog","slug":"开篇：Hexo-Github搭建的个人博客","date":"2017-11-05T15:32:38.000Z","updated":"2017-11-06T04:14:59.000Z","comments":true,"path":"2017/11/05/开篇：Hexo-Github搭建的个人博客/","link":"","permalink":"http://yoursite.com/2017/11/05/开篇：Hexo-Github搭建的个人博客/","excerpt":"","text":"伊始并非所有事都需要充分的理由，比如此间的诞生，仅仅是想而已。自今天7月实习以来，coding日渐成为生活中重要的一部分，是形势所趋，也是兴致始来。我开始关注各大程序员公众号、浏览各种业内主流网站，在这之中，我见识了几位资深coder的独立博客。 我对独立博客的最初感受是，它的内容与那些主流网站注册的博客内容很不同，谈技术往往更深入，谈生活往往更真实，在独立博客总能找到货真价实的东西。在这个过程中，我看到了Jark's Blog。在看他的《Hello独立博客》时，我第一次萌生了搭建个人博客的想法。 自九月准备秋招起，我每天大部分时间都泡在牛客网、LeetCode、Java书本上，这其中学习了很多东西，但也让我感到了隐患： 一是有些知识点并非过一遍就能掌握，需要反复练习、值得深入了解。 二是短时间接触的东西多了不记记很容易有所忘记。 于是马上想到的办法是用有道云笔记把每天学到的东西都做记录，这个习惯留到了现在。但是我始终觉得，这样是不够的。 首先，我一直认为干这行闭门造车是很困难的，交流是更有效的进步方法，尤其是当技术在不断更新时。 其次，就未来职业发展考虑，有一个展示自己的平台当是很有优势的。 所以，即使明知自己是个技术小白，搭建独立博客的想法却愈发明朗，尤其是在B站看见了船长俱乐部后。 考虑到自身经验不足，在正式开始前，算是做了一定的准备，包括看视频、读文档，最终选择了Hexo+Github这种比较容易的方式。（其实更早的时候看到有人用SSM框架完全自主搭建：一个简单漂亮的SSM(Spring+SpringMVC+Mybatis)博客系统，感觉甚是酷炫。） 从技术上说没有多少难度，Hexo甚至有中文官网供参考：快速、简洁且高效的博客框架，船长的视频[Crazy Blog] 利用Hexo搭建自己的个人博客(Mac)讲解得也够细。 然而真正到了实际操作仍然磕磕绊绊，网络环境是主要原因，本地环境混乱可能也造成了一定麻烦（比如安装Hexo时找不到python2路径）。比较大的问题大约有两处，因为没有截图，在此就不赘述了。当时上网查找资料，竟无人遇到与我相似的问题。但几次清空、重装后竟奇迹般地通过，算是幸运了。经历这一遭也感觉对Mac系统（本质上也是linux吧）理解还不够。在此概述一下Mac安装的过程： 首先是Hexo的安装及初始化 1、安装git、Node.js 2、安装Hexo：1$ sudo npm install hexo-cli -g3、创建一个本地安放博客的路径：1$ mkdir /your/path/for/blog4、进入第3步创建的文件夹，初始化hexo，安装依赖包：123$ cd /your/path/for/blog$ hexo init$ npm install5、本地查看，先敲击下面的命令，然后在浏览器访问本地端口4000 ：1$ hexo server这里有几点需要注意：1、由于国内的网络环境，安装包的下载用时可能会非常长。所以你懂的……2、安装Hexo可能会报错，对于这种情况，网上说法不一，有的说要换源，有的说要更改指令。由于在这一步卡了很久，我基本把找到的办法都尝试了一遍。这种情况因人而异，建议在重装前把先前失败后留下的残余文件清理一遍，其实就是你创建的那个安放博客的目录，否则可能在后续安装的过程中会产生冲突。 如果顺利的话，到此应该就能在浏览器看到自己的本地初始化博客了。 下面讲一下Github上的配置 1、登陆github，创建一个新的仓库，也就是你的博客地址:1https://github.com/new2、Repository name务必按照如下格式，设置为public，最后点击 create repository：1&quot;你的github名字&quot;.github.io3、接着上一步，现在能看到Quick steup，点击SSH，检查一下右边路径。 4、如果第一次使用git，需要在本地配置git个人信息，打开终端输入：12$ git config --global user.name &quot;你的github上的名字&quot;$ git config --global user.mail &quot;你注册github的邮箱&quot;5、生成ssh密钥：输入下列指令，然后一路敲回车：1$ ssh-keygen -t rsa -C &quot;你注册github的邮箱&quot;6、找到刚刚生成的ssh密钥的路径，打开对应文件，将密钥拷贝出来：12$ cd ~/.ssh$ less id_rsa.pub7、在浏览器登录github，点击头像，点击Settings，左侧找到SSH and GPG keys，点击进入。 8、点击右上角New SSH key，Title自定义，Key的内容为第6步拷贝的内容，最后点击Add SSH key。 9、终端输入下面指令，验证ssh：1$ ssh -T git@github.com 10、安装git插件，确保终端当前目录是你的博客，输入：1$ npm install hexo-deployer-git --save 11、配置_config.xml文件。用文本编辑器打开，找到#Deployment，如下配置：1234deploy: type: git repo: git@github.com:YourName/YourName.github.io branch: master12、部署至github。在你的博客目下输入下面指令，需要等待一段时间：1$ hexo deploy 现在在浏览器输入”YourName”.github.io，顺利的话就能看到自己的初始博客了！","categories":[],"tags":[]}]}